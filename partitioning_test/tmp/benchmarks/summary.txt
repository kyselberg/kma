Підсумки бенчмарків (у контексті нашого сетапу)

Контекст
- Дані: ~500 тис/місяць, 24 місяці ≈ 12 млн рядків, ~1000 тенантів
- Варіанти середовищ:
  - Plain: без партицій, одна таблиця `app.events_plain`
  - Variant A: RANGE-партиції по місяцю (`app.events` + `app.events_YYYY_MM`)
  - Variant B: HASH-шардинг по `tenant_id` через FDW (`app.events_sharded` → 2 шари)

Підсумкові часи (Execution Time, приблизно)
- Пошук за id:
  - Plain: ~1.2 ms
  - Variant A: ~1.7 ms
  - Variant B: ~110 ms
- count(*) за останній місяць (тільки фільтр часу):
  - Plain: ~37 ms
  - Variant A: ~87 ms
  - Variant B: ~23 227 ms
- count(*) для 1 тенанта за останні 3 місяці (tenant_id + час):
  - Plain: ~2.5 ms
  - Variant A: ~0.48 ms
  - Variant B: ~44.9 ms
- Ролап по місяцях за рік (GROUP BY month):
  - Plain: ~6.23 с
  - Variant A: ~3.00 с
  - Variant B: ~20.0 с
- INSERT 10 рядків:
  - Plain: ~21.7 ms
  - Variant A: ~21.1 ms
  - Variant B: ~14.0 ms

Інтерпретація
- Variant A (місячні RANGE-партиції)
  - Сильно виграє на часових і tenant-скоплених запитах (прюнінг до 1–3 партицій, паралелізм між партиціями).
  - Ролап за рік у ~2× швидший за Plain завдяки розподіленню скану по партиціях і HashAggregate.
  - Мінус: пошук лише за id гірший за Plain, бо ключ партиціювання — час, тому доводиться перевіряти багато партицій.
- Plain (без партицій)
  - Дуже сильний на селективних index-only сканах (точка за id, підрахунок за місяць) і простих вставках.
  - Просідає на великих аналітичних сканах з сортуванням/агрегацією (є зовнішні сорти зі спілам на диск ~141 МБ).
- Variant B (FDW-шардинг за tenant_id)
  - У цьому сетапі читання повільні через слабкий pushdown: фільтри за часом часто застосовуються локально на координаторі, тягнучи багато рядків з шардів; partitionwise aggregate не спрацьовує ефективно.
  - Перевага: найменший оверхед на INSERT (координатор швидко роутить на шари).

Рекомендації
- Для нашого типовго навантаження (часові й tenant-скоплені запити) базовим вибором має бути Variant A.
- Якщо домінують лише пошуки за id і обсяг даних відносно невеликий — Plain простіший і інколи швидший.
- Для Variant A:
  - Оптимізувати підрахунок за місяць: розглянути BRIN на `occurred_at` в кожній партиції або тюнінг `random_page_cost`/`effective_cache_size`, щоб частіше обирати index-only; за потреби — часткові індекси для «гарячих» місяців.
  - Якщо часто потрібен lookup тільки за id, варто або знати відповідний місяць під час запиту (щоб одразу таргетити партицію), або змінити ключ партиціювання/додати допоміжну структуру маршрутизації.
- Для Variant B, щоб конкурувати на читаннях:
  - Писати запити так, щоб координатор міг пушдаунити і tenant, і час одночасно (фільтри мають бути простими та pushdown-safe).
  - Переконатися в наявності релевантних індексів на шардах (`occurred_at`, `(tenant_id, occurred_at)`), увімкнути `use_remote_estimate`, підібрати `fetch_size`.
  - Розглянути інструменти з кращим розподіленим плануванням (наприклад, Citus) для складних агрегацій.

Нотатки з планів виконання
- Plain: для річного ролапу — Index Only Scan + зовнішній Merge Sort зі спілом на диск (~141 МБ).
- Variant A: прюнінг до 1 партиції для місячного фільтра; для ролапу — Parallel Append + HashAggregate, суттєвий виграш проти Plain.
- Variant B: часто видно, що координатор робить локальний фільтр часу після Foreign Scan; звідси високі латентності на «time-only» і агрегаційних запитах.

Цей звіт представляє результати порівняльного аналізу продуктивності реляційної та колоночної СУБД. Метою дослідження було визначення їхньої ефективності на реалістичних бізнес-сценаріях, що включало оцінку швидкості виконання аналітичних запитів різної складності.
В якості реляційної СУБД використано PostgreSQL, а в якості стовпчикової - ClickHouse

Структура та генерація даних
Тестове середовище базувалося на схемі даних, що імітує транзакційну активність:

Таблиця products
id - унікальний ідентифікатор
name - назва продукту
price - ціна в копійках
created_at - час створення
Приклади продуктів: Молоко, Хліб, Яйця, Масло, Яблука, Банани, Кава, Чай, Туалетний папір, Шампунь, тощо.

Таблиця markets
id - унікальний ідентифікатор
name - назва магазину
created_at - час створення
Магазини: 20 точок мережі Novus у різних районах Києва (Печерський, Оболонський, Дарницький, Подільський, та ін.)

Таблиця transactions
id - унікальний ідентифікатор транзакції
market_id - ідентифікатор магазину
total_amount - загальна сума чека
item_count - кількість позицій у чеку
transaction_date - дата і час транзакції
created_at - час створення запису

Таблиця transaction_items
transaction_id - ідентифікатор транзакції
product_id - ідентифікатор продукту
quantity - кількість
unit_price - ціна за одиницю
total_price - загальна вартість позиції
transaction_date - дата транзакції
market_id - ідентифікатор магазину

Дані генерувалися з урахуванням реалістичних параметрів:
Кожна транзакція містить 5-50 товарних позицій
Випадковий магазин з 20 можливих
Випадкова дата протягом останніх 365 днів
Випадкові продукти з ціною 100-4900 копійок
Кількість кожного товару: 1-10 одиниць

Результат генерації:
PostgreSQL:
1,000,000 транзакцій
27,486,996 товарних позицій
ClickHouse:
1,000,000 транзакцій
30,798,578 товарних позицій

Застосовані оптимізації

Для забезпечення об'єктивного порівняння обидві СУБД були налаштовані з урахуванням їхніх сильних сторін для аналітичних навантажень:

Для PostgreSQL:
Партиціювання: Таблиці transactions та transaction_items були розділені на ~60 партицій за тижневим принципом для прискорення запитів із часовими діапазонами.
Індексація: На кожну партицію було створено понад 180 індексів для оптимізації операцій JOIN та фільтрації.
Конфігурація: Оптимізовано параметри shared_buffers та work_mem для кращої роботи з даними в пам'яті.

Для ClickHouse:
Партиціювання: Застосовано автоматичне місячне партиціювання.
Структура даних: Використано оптимізований ORDER BY для первинного ключа, що прискорює вибірку даних.
Агрегація: Були створені Projections та дві Materialized Views для попереднього розрахунку агрегатів (щоденні продажі, пари продуктів).
Типи даних: Застосовано типи з низькою кардинальністю (LowCardinality) та оптимізовані числові типи (UInt) для зменшення споживання пам'яті.

Аналіз результатів продуктивності

Прості агрегаційні запити
На базових запитах, таких як підрахунок загальної кількості рядків (COUNT) або розрахунок суми за період (SUM), ClickHouse продемонстрував перевагу завдяки своїй колоночній архітектурі. Перевага була особливо помітною (в 1.9 рази) при повному скануванні таблиці.

Загальна кількість товарів
PostgreSQL: 75.49 мс
ClickHouse: 39.83 мс
Переможець: ClickHouse (1.9х)

Сума за 2 місяці
PostgreSQL: 25.91 мс
ClickHouse: 23.88 мс
Переможець: ClickHouse (1.08х)


Запити з об'єднанням таблиць (JOIN) та агрегацією
У цій категорії результати виявилися неоднозначними. ClickHouse показав себе майже в 5 разів швидшим при розрахунку доходу від конкретного продукту, де ефективно спрацювало зчитування лише необхідних колонок. Однак PostgreSQL виявився трохи швидшим при об'єднанні з невеликою таблицею-довідником магазинів, що свідчить про важливість його оптимізатора для класичних JOIN-операцій.

Дохід від продукту
PostgreSQL: 1,450.83 мс
ClickHouse: 296.20 мс
Переможець: ClickHouse (4.9х)

Дохід магазину
PostgreSQL: 33.04 мс
ClickHouse: 37.42 мс
Переможець: PostgreSQL (1.13х)

Складні аналітичні запити (Market Basket Analysis)
Найцікавіші результати були отримані на комбінаторних задачах з пошуку товарів, що купуються разом.
Пошук пар: ClickHouse впорався із завданням в 1.4 рази швидше.
Пошук трійок та четвірок: Зі зростанням складності PostgreSQL продемонстрував значну перевагу, виявившись швидшим в 1.6 та 2.3 рази відповідно. Його оптимізатор та ефективна реалізація LATERAL JOIN виявилися більш пристосованими до експоненційного зростання кількості комбінацій, на відміну від ARRAY JOIN у ClickHouse.

ТОП-10 пар продуктів
PostgreSQL: 1,456 мс
ClickHouse: 1,018 мс
Переможець: ClickHouse (1.4х)

ТОП-10 трійок продуктів
PostgreSQL: 6,818 мс
ClickHouse: 11,003 мс
Переможець: PostgreSQL (1.6х)

ТОП-10 четвірок продуктів
PostgreSQL: 53,707 мс
ClickHouse: 122,472 мс
Переможець: PostgreSQL (2.3х)

Порівняння з денормалізованою схемою
Для повноти дослідження було проведено додатковий експеримент із денормалізованою схемою даних, де вся інформація зберігається безпосередньо в таблиці transaction_items без використання зовнішніх ключів та JOIN-операцій. Замість посилань на таблиці products та markets, назви продуктів (product_name) та магазинів (market_name) зберігаються прямо у кожному рядку транзакції.

Прості агрегаційні запити (денормалізовані дані)
На простих агрегаційних запитах денормалізація показала суттєве покращення для PostgreSQL завдяки відсутності необхідності в JOIN-операціях. ClickHouse також отримав певну перевагу, але різниця була менш виразною через його природну оптимізацію для колоночного сканування.

Загальна кількість товарів
PostgreSQL: 148.74 мс
ClickHouse: 53.98 мс
Переможець: ClickHouse (2.75х)

Сума за 2 місяці
PostgreSQL: 55.24 мс
ClickHouse: 47.27 мс
Переможець: ClickHouse (1.17х)

Запити з агрегацією за атрибутами (денормалізовані дані)
У цій категорії денормалізація дозволила PostgreSQL значно скоротити час виконання запитів завдяки уникненню JOIN-операцій. ClickHouse показав вражаючі результати на запитах із фільтрацією, прискорившись у 13-21 раз порівняно з нормалізованою схемою.

Дохід від продукту
PostgreSQL: 901.36 мс
ClickHouse: 68.00 мс
Переможець: ClickHouse (13.3х)

Дохід від продукту в магазині
PostgreSQL: 568.49 мс
ClickHouse: 50.75 мс
Переможець: ClickHouse (11.2х)

Дохід магазину
PostgreSQL: 610.90 мс
ClickHouse: 52.86 мс
Переможець: ClickHouse (11.6х)

Складні аналітичні запити з денормалізацією
На комбінаторних задачах денормалізація дещо вирівняла співвідношення сил, оскільки обидві СУБД отримали однакові умови без JOIN-операцій. Результати показали цікаву закономірність:

Пари продуктів
PostgreSQL: 1,104.63 мс
ClickHouse: 1,024.21 мс
Переможець: ClickHouse (1.08х)

Трійки продуктів
PostgreSQL: 7,864.23 мс
ClickHouse: 9,173.19 мс
Переможець: PostgreSQL (1.17х)

Четвірки продуктів
PostgreSQL: 64,107.16 мс
ClickHouse: 71,151.16 мс
Переможець: PostgreSQL (1.11х)

Висновки
Сильні сторони PostgreSQL СУБД: Висока ефективність на складних JOIN-операціях та комбінаторних запитах.
Сильні сторони ClickHouse: Висока швидкість на агрегаційних запитах (SUM, COUNT, AVG).

Вплив денормалізації: Денормалізація даних показала різний вплив на продуктивність обох СУБД. Для ClickHouse денормалізація виявилася особливо ефективною — на запитах з фільтрацією та агрегацією (дохід від продукту, дохід магазину) продуктивність покращилася в 4-5 разів порівняно з нормалізованою схемою (з 296 мс до 68 мс для доходу продукту). Це підтверджує, що колоночні СУБД максимально розкривають свій потенціал саме на денормалізованих схемах, де відсутні JOIN-операції та дані зберігаються в єдиній таблиці. Для PostgreSQL денормалізація також покращила простіші запити, але на складних комбінаторних задачах вплив був мінімальним.

Загальний висновок: Вибір СУБД залежить від пріоритетів проекту. Для систем, що вимагають одночасно надійної обробки транзакцій та швидкої аналітики, оптимальною є гібридна архітектура: PostgreSQL виступає в ролі основної бази для операцій запису (OLTP), а дані періодично реплікуються в ClickHouse для виконання аналітичних запитів та побудови звітності (OLAP). При цьому для ClickHouse рекомендується використовувати денормалізовану схему даних, що дозволяє досягти максимальної продуктивності на аналітичних запитах.
